# 1. OOP 기본 개념
- 필요한 타입을 설계
- 상태를 나타내는 데이터와 상태를 조작하는 함수를 묶어서 타입을 설계 
- = 보다 안전하고, 사용하기 쉬운 타입을 설계 할 수 있음
- `C`언어는 구조체 안에 함수를 넣을 수 없고, `C++`은 구조체 안에 함수를 넣을 수 있음
- 멤버 함수는 **객체의 개수에 상관없이 코드 메모리에 한 개**만 만들어짐


### 1) 접근 지정자
- 멤버 데이터를 외부에서 직접 접근하면 객체가 잘못된 상태가 될 수도 있음
- 멤버 데이터는 "외부의 잘못된 사용으로부터 보호"하는 것이 안전함
- 구조체는 접근 지정자 생략시 `public`
- 클래스는 접근 지정자 생략시 `private`

|||
|-|-|
|`private`|멤버 함수에서만 접근 가능|
|`public`|모든 함수에서 접근 가능|
|`protected`|멤버 함수와 파생 클래스 멤버 함수에서 접근 가능|

> **캡슐화(Encapsulation)** <br>
\- 멤버 데이터는 private 영역에 두고, 외부의 잘못된 사용으로 부터 보호 <br>
\- 멤버 데이터의 변경은 잘 정의된 규칙을 가진 멤버 함수를 통해서만 변경 가능하도록 함


### 2) Constructor/Destructor
- 생성자는 반환 타입을 표기하지 않고, 값을 반환할 수 없음
- 생성자는 함수 오버로딩을 지원함
- 사용자가 생성자를 한 개도 만들지 않으면 컴파일러가 디폴트 생성자를 제공함
- `malloc`은 생성자를 부를 수 없고, `new`는 생성자를 부를 수 있음
- 객체 생성시, 멤버의 생성자가 먼저 호출되고, 객체 자신의 생성자가 호출됨

||||
|-|-|-|
|생성자|`클래스이름()` 모양의 함수| 객체를 생성할 때 자동으로 호출되는 함수
|소멸자|`~클래스이름()` 모양의 함수| 객체가 파괴 될 때 자동으로 호출되는 함수

# 2. Vector
- C++언어의 표준 라이브러리
- 대부분 템플릿으로 되어 있음
- Standard Template Library
- 크기 변경이 가능한 동적 배열
- 사용법은 배열과 거의 동일함

# 3. member initializer list
- 생성자에서 멤버 데이터를 초기화 할 때는 "멤버 초기화 리스트(member initializer list)"를 사용하는 것이 좋음
- 반드시 member initializer list를 사용해야 하는 경우
    - 멤버 데이터로 **상수나 참조자가 있는 경우** (반드시 초기화 되어야 함)
    - **디폴트 생성자가 없는 타입이 멤버로 있는 경우**

```cpp
class People
{
    std::string name;
    int age;
public:
    People(const std::string& s, int a) : name{s}, age{a} // 이렇게 초기화 하자!!
    {
        // 이렇게 하지말고,
        name = s; // 초기화가 아니라 대입 ..!!
        age = a;
    }
}
```
- 초기화 코드가 놓인 순서가 아니라, 멤버 데이터가 선언된 순서 대로 초기화 됨!!!
```cpp
class Point
{
public:
//	int x;
	int y;
	int x;

	Point() : y{10}, x{y}
	{
	}
};
```
- 선언과 구현 파일로 나누어 클래스를 작성할 때, 멤버 초기화 리스트는 **구현 파일**에 작성
- 생성자 블록 안에서는 멤버에 접근하려면 `this->멤버이름`을 사용해야 함 (멤버 초기화 리스트의 경우는 필요 없음)
- (참고) 컴파일러의 멤버 초기화 리스트를 해석
```cpp
#include <iostream>

int g = 0;

class Point
{
public:
//	int x{0}; // int x = 0;
	int x{++g};
	int y{0};

	Point() {}
	Point(int a)        : x{a} {}
	Point(int a, int b) : x{a}, y{b} {}
};

int main()
{
	Point pt1;     // 0, 0
	Point pt2(1);  // 1, 0

	std::cout << pt1.x << ", " << pt1.y << std::endl;
	std::cout << pt2.x << ", " << pt2.y << std::endl;

	std::cout << g << std::endl; // 1
}
```